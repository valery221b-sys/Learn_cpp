## Arithmetic Operators (Арифметические операторы)

---

**Base**

### 1. Основные арифметические операторы

- `+` — сложение
- `-` — вычитание
- `*` — умножение
- `/` — деление
- `%` — остаток от деления (remainder)

Примеры:

```c++
int a = 7;
int b = 3;
int sum = a + b;     // 10
int diff = a - b;    // 4
int prod = a * b;    // 21
int divi = a / b;    // 2  (целочисленное деление)
int rem = a % b;     // 1  (остаток)

double x = 7.0, y = 3.0;
double fd = x / y;   // 2.333333...
```

### 2. Унарные операторы и инкременты/декременты

- Унарный `+` и `-`
- Префиксный и постфиксный `++`/`--`

Пример:

```c++
int i = 0;
int a1 = ++i; // префикс: i становится 1, a1 == 1
int i2 = 0;
int b1 = i2++; // постфикс: b1 == 0, затем i2 становится 1
```

### 3. Сочетанные присваивания

- `+=`, `-=`, `*=`, `/=`, `%=` — для сокращения записи и возможной оптимизации.

```c++
int v = 10;
v += 5; // v == 15
v *= 2; // v == 30
```

---

**Advance**

### 4. Целочисленное деление и остаток (особенности)

- В C++ целочисленное деление усечения ведёт к отсечению дробной части (truncation toward zero). Пример: `-7 / 3 == -2`.
- Остаток вычисляется по формуле `a == (a/b)*b + (a%b)`, знак остатка соответствует делимому: `-7 % 3 == -1`.

Пример:

```c++
int a = -7, b = 3;
std::cout << (a / b) << '\n'; // -2
std::cout << (a % b) << '\n'; // -1
```

### 5. Приведение типов и "usual arithmetic conversions"

- При смешанных типах применить правила продвижения: меньшие целые типы продвигаются до `int`, затем при необходимости привести к `double` и т.д.
- Обратить внимание: `int / int` → целое, даже при присвоении в `double`.

### 6. Переполнение и безопасность

- Для беззнаковых целых (`unsigned`) переполнение определить как арифметику по модулю 2^N (wrap-around).
- Для знаковых целых переполнение — неопределённое поведение; избегать и проверять диапазоны.

Пример с unsigned:

```c++
unsigned int u = std::numeric_limits<unsigned int>::max();
u += 1; // теперь 0 (wrap-around)
```

### 7. Побочные эффекты и последовательность вычислений

- Избегать выражений, которые изменяют одну переменную несколько раз без промежуточной последовательности (может привести к неопределённому поведению).

```c++
// НЕ ДЕЛАТЬ
int i = 0;
int x = i++ + ++i; // UB — не делать так
```

Разделять вычисления на отдельные выражения для ясности.

### 8. Точность с плавающей точкой

- Принять во внимание, что операции с `float`/`double` не ассоциативны из-за округлений: `(a+b)+c` может отличаться от `a+(b+c)`.
- При необходимости повышать точность отдельных вычислений с помощью `std::fma` (fused multiply-add).

### 9. Приоритет и ассоциативность операторов

- Умножение/деление/остаток имеют более высокий приоритет, чем сложение/вычитание.
- Применять скобки для повышения читаемости и контроля порядка вычислений.

Краткая таблица приоритетов (важные для арифметики):

- `()` (скобки)
- унарные `+ -` и `++ --` (высокий приоритет)
- `* / %`
- `+ -`

### 10. Рекомендации и практические советы

- Для деления с дробной частью явно приводить операнды к плавающему типу: `static_cast<double>(a) / b`.
- Не полагаться на поведение при переполнении знаковых целых; использовать проверки или типы большей разрядности.
- Для точных финансовых расчётов использовать целочисленные представления копеек/центов или специализированные библиотеки.

---

### 11. Операторы сравнения

- `==` равенство
- `!=` неравенство
- `<`, `<=`, `>`, `>=` — отношения упорядочения

Особенности:

- При сравнении вещественных чисел учитывать ошибки округления и применять эпсилон: `std::fabs(a-b) < eps`.
- Избегать прямого сравнения знаковых и беззнаковых типов без приведения: привести один из операндов к нужному типу.

Пример:

```c++
double a = 0.1 * 3;
double b = 0.3;
bool approx = std::fabs(a - b) < 1e-12; // приблизительное равенство

int n = -1;
unsigned int u = 1u;
// сравнивать после явного приведения, чтобы избежать нежелательного приведения знакового в unsigned
bool cmp = static_cast<int>(u) > n;
```

### 12. Побитовые операторы

- `&` — побитовое AND
- `|` — побитовое OR
- `^` — побитовое XOR
- `~` — побитовое NOT (унарный)
- `<<` — сдвиг влево
- `>>` — сдвиг вправо

Особенности и рекомендации:

- Для беззнаковых типов сдвиги определены как логический сдвиг; для знаковых — поведение при сдвиге отрицательных значений реализационно-зависимо.
- Сдвиг влево, который сдвигает единицу за пределы разрядности знакового типа, может приводить к неопределённому поведению; для битовых масок использовать беззнаковые типы.
- Для флагов и масок рассматривать использование `unsigned` или `std::bitset`.

Примеры:

```c++
unsigned int flags = 0;
flags |= (1u << 2); // установить бит 2
bool bit2 = (flags & (1u << 2)) != 0;
flags &= ~(1u << 2); // сбросить бит 2

unsigned int v = 1u << 31; // сдвиг влево на 31 для 32-битного unsigned

int s = -1;
int r = s >> 1; // поведение сдвига для отрицательных значений зависит от реализации (обычно арифметический сдвиг)
```

---

### Примеры (компилируемый файл)

```c++
// operations_example.cpp
#include <iostream>
#include <limits>
#include <cmath>
#include <bitset>

int main() {
	int a = 7, b = 3;
	std::cout << "7/3 = " << (a / b) << "  7.0/3.0 = " << (7.0 / 3.0) << '\n';

	int neg = -7;
	std::cout << "-7/3 = " << (neg / b) << "  -7%3 = " << (neg % b) << '\n';

	unsigned int u = std::numeric_limits<unsigned int>::max();
	std::cout << "unsigned max = " << u << '\n';
	u += 1;
	std::cout << "after +1 -> " << u << " (wrap-around)" << '\n';

	int i = 0;
	std::cout << "postfix i++ yields " << i++ << ", now i = " << i << '\n';

	double x = 0.1 * 3;
	double y = 0.3;
	std::cout << std::setprecision(17) << "0.1*3 = " << x << "  0.3 = " << y << '\n';
	std::cout << std::boolalpha << "equal? " << (x == y) << '\n';

	unsigned int flags = 0;
	flags |= (1u << 2);
	std::cout << "flags (bit2 set): " << std::bitset<8>(flags) << '\n';

	return 0;
}
```